// Generated by CoffeeScript 1.10.0
var B64, UTF8, char, cls, get, i, j, jsonp, len1, make, ref, text, xhr,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  hasProp = {}.hasOwnProperty;

get = function(opts) {
  var el, els, hasCls, inside, ref, ref1, ref2, ref3, tag;
  if (opts == null) {
    opts = {};
  }
  inside = (ref = opts.inside) != null ? ref : document;
  tag = (ref1 = opts.tag) != null ? ref1 : '*';
  if (opts.id != null) {
    return inside.getElementById(opts.id);
  }
  hasCls = opts.cls != null;
  if (hasCls && tag === '*' && (inside.getElementsByClassName != null)) {
    return inside.getElementsByClassName(opts.cls);
  }
  els = inside.getElementsByTagName(tag);
  if (hasCls) {
    els = (function() {
      var j, len1, results;
      results = [];
      for (j = 0, len1 = els.length; j < len1; j++) {
        el = els[j];
        if (cls(el, {
          has: opts.cls
        })) {
          results.push(el);
        }
      }
      return results;
    })();
  }
  if ((opts.multi == null) && (ref2 = tag.toLowerCase(), indexOf.call(get.uniqueTags, ref2) >= 0)) {
    return (ref3 = els[0]) != null ? ref3 : null;
  } else {
    return els;
  }
};

get.uniqueTags = 'html body frameset head title base'.split(' ');

make = function(opts) {
  var c, j, k, len1, ref, t, v;
  if (opts == null) {
    opts = {};
  }
  t = document.createElement((ref = opts.tag) != null ? ref : 'div');
  for (k in opts) {
    if (!hasProp.call(opts, k)) continue;
    v = opts[k];
    switch (k) {
      case 'tag':
        continue;
      case 'parent':
        v.appendChild(t);
        break;
      case 'kids':
        for (j = 0, len1 = v.length; j < len1; j++) {
          c = v[j];
          if (c != null) {
            t.appendChild(c);
          }
        }
        break;
      case 'prevSib':
        v.parentNode.insertBefore(t, v.nextSibling);
        break;
      case 'text':
        t.appendChild(text(v));
        break;
      case 'cls':
        t.className = v;
        break;
      default:
        t[k] = v;
    }
  }
  return t;
};

text = function(t) {
  return document.createTextNode('' + t);
};

cls = function(el, opts) {
  var addClasses, c, classHash, classes, hasClasses, j, k, l, len1, len2, len3, len4, len5, m, n, o, ref, ref1, ref2, ref3, removeClasses, toggleClasses;
  if (opts == null) {
    opts = {};
  }
  classHash = {};
  classes = el.className.match(cls.re);
  if (classes != null) {
    for (j = 0, len1 = classes.length; j < len1; j++) {
      c = classes[j];
      classHash[c] = true;
    }
  }
  hasClasses = (ref = opts.has) != null ? ref.match(cls.re) : void 0;
  if (hasClasses != null) {
    for (l = 0, len2 = hasClasses.length; l < len2; l++) {
      c = hasClasses[l];
      if (!classHash[c]) {
        return false;
      }
    }
    return true;
  }
  addClasses = (ref1 = opts.add) != null ? ref1.match(cls.re) : void 0;
  if (addClasses != null) {
    for (m = 0, len3 = addClasses.length; m < len3; m++) {
      c = addClasses[m];
      classHash[c] = true;
    }
  }
  removeClasses = (ref2 = opts.remove) != null ? ref2.match(cls.re) : void 0;
  if (removeClasses != null) {
    for (n = 0, len4 = removeClasses.length; n < len4; n++) {
      c = removeClasses[n];
      delete classHash[c];
    }
  }
  toggleClasses = (ref3 = opts.toggle) != null ? ref3.match(cls.re) : void 0;
  if (toggleClasses != null) {
    for (o = 0, len5 = toggleClasses.length; o < len5; o++) {
      c = toggleClasses[o];
      if (classHash[c]) {
        delete classHash[c];
      } else {
        classHash[c] = true;
      }
    }
  }
  el.className = ((function() {
    var results;
    results = [];
    for (k in classHash) {
      results.push(k);
    }
    return results;
  })()).join(' ');
  return null;
};

cls.re = /\S+/g;

jsonp = function(opts) {
  var callbackName, ref, ref1, url;
  callbackName = (ref = opts.callback) != null ? ref : '_JSONPCallback_' + jsonp.callbackNum++;
  url = opts.url.replace('<cb>', callbackName);
  window[callbackName] = (ref1 = opts.success) != null ? ref1 : jsonp.noop;
  return make({
    tag: 'script',
    src: url,
    parent: get({
      tag: 'head'
    })
  });
};

jsonp.callbackNum = 0;

jsonp.noop = function() {};

xhr = function(opts) {
  var k, method, ref, ref1, req, v;
  if (opts == null) {
    opts = {};
  }
  method = (ref = opts.method) != null ? ref : 'GET';
  req = new XMLHttpRequest();
  req.onreadystatechange = function() {
    if (req.readyState === 4 && (req.status === 200 || !location.href.match(/^https?:/))) {
      return opts.success(req);
    }
  };
  if (opts.binary) {
    req.overrideMimeType('text/plain; charset=x-user-defined');
  }
  if (opts.mime != null) {
    req.overrideMimeType(opts.mime);
  }
  if (opts.user != null) {
    req.user = opts.user;
  }
  if (opts.password != null) {
    req.password = opts.password;
  }
  if (opts.headers != null) {
    ref1 = opts.headers;
    for (k in ref1) {
      v = ref1[k];
      req.setRequestHeader(k, v);
    }
  }
  req.open(method, opts.url);
  req.send(opts.data);
  return true;
};

UTF8 = {
  enc: function(s) {
    return unescape(encodeURIComponent(s));
  },
  dec: function(s) {
    return decodeURIComponent(escape(s));
  }
};

B64 = {
  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split(''),
  nonchars: new RegExp('[^A-Za-z0-9+/=]+', 'g'),
  enc: function(input, output) {
    var chars, chr1, chr2, chr3, i, len, padLen, padded;
    if (output == null) {
      output = '';
    }
    chars = B64.chars;
    len = input.length;
    padLen = [0, 2, 1][len % 3];
    padded = padLen === 0 ? input : input + '\x00\x00'.substring(0, padLen);
    i = 0;
    while (i < len) {
      chr1 = padded.charCodeAt(i++) & 255;
      chr2 = padded.charCodeAt(i++) & 255;
      chr3 = padded.charCodeAt(i++) & 255;
      output += chars[chr1 >> 2];
      output += chars[((chr1 & 3) << 4) | (chr2 >> 4)];
      output += chars[((chr2 & 15) << 2) | (chr3 >> 6)];
      output += chars[chr3 & 63];
    }
    if (padLen === 0) {
      return output;
    } else {
      return output.substring(0, output.length - padLen) + '=='.substring(0, padLen);
    }
  },
  dec: function(input, sanitize, output) {
    var charmap, chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, len;
    if (sanitize == null) {
      sanitize = true;
    }
    if (output == null) {
      output = '';
    }
    if (sanitize) {
      input = input.replace(B64.nonchars, '');
    }
    charmap = B64.charmap;
    len = input.length;
    i = 0;
    while (i < len) {
      enc1 = charmap[input.charAt(i++)];
      enc2 = charmap[input.charAt(i++)];
      enc3 = charmap[input.charAt(i++)];
      enc4 = charmap[input.charAt(i++)];
      chr1 = (enc1 << 2) | (enc2 >> 4);
      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
      chr3 = ((enc3 & 3) << 6) | enc4;
      output += String.fromCharCode(chr1, chr2, chr3);
    }
    if (enc4 !== 64) {
      return output;
    } else {
      return output.substring(0, output.length - (enc3 === 64 ? 2 : 1));
    }
  }
};

B64.charmap = {};

ref = B64.chars;
for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
  char = ref[i];
  B64.charmap[char] = i;
}

//# sourceMappingURL=affogato.js.map
